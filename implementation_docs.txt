Django Chat App Implementation Documentation
==========================================

1. Project Overview
-------------------
This document outlines the implementation of a real-time chat application using Django and Django Channels. The goal was to create a "spike" or proof-of-concept for a chat system that supports:
- Real-time messaging (instant updates without page reloads).
- Group chat rooms.
- Private 1-on-1 messaging.
- Message persistence (history is saved).
- Passwordless authentication (username-only entry).

2. Technology Stack
-------------------
- **Backend**: Django 6.0 (Web Framework)
- **Real-time Protocol**: WebSockets via Django Channels 4.0+
- **Server Interface**: ASGI (Asynchronous Server Gateway Interface) via Daphne
- **Database**: SQLite (Default Django DB)
- **Frontend**: HTML5, CSS3 (Dark Mode), Vanilla JavaScript (WebSocket API)

3. Key Concepts & Architecture
------------------------------
Unlike standard Django which uses WSGI (synchronous), this app uses ASGI to handle asynchronous WebSocket connections.

### 3.1. Django Channels
Django Channels extends Django to handle WebSockets. It replaces the standard request-response cycle with a long-lived connection model.

### 3.2. Channel Layers
We used `InMemoryChannelLayer` for development. This allows different instances of the application (consumers) to talk to each other. In production, this would typically be replaced by Redis.
- **Role**: It acts as the communication bus. When User A sends a message, the consumer sends it to the "Group" in the channel layer, which then broadcasts it to all other connected users in that group.

4. Implementation Details
-------------------------

### 4.1. Configuration (`settings.py` & `asgi.py`)
- **`daphne`** was added to `INSTALLED_APPS` to serve the ASGI application.
- **`channels`** was added to enable Channels functionality.
- **`ASGI_APPLICATION`** was pointed to `chat_app.asgi.application`.
- **`CHANNEL_LAYERS`** was configured to use the in-memory backend.

**File: `chat_app/asgi.py`**
We wrapped the standard Django ASGI application with `ProtocolTypeRouter`.
- `http`: Handled by standard Django.
- `websocket`: Handled by `AuthMiddlewareStack` (for user sessions) and `URLRouter` (for custom WebSocket URLs).

### 4.2. Routing (`chat/routing.py`)
Similar to `urls.py` for HTTP, `routing.py` handles WebSocket URL patterns.
- We defined routes like `ws/chat/group/<room_name>/` to route connections to the `ChatConsumer`.

### 4.3. Consumers (`chat/consumers.py`)
This is the equivalent of "Views" for WebSockets. We implemented `ChatConsumer` inheriting from `AsyncWebsocketConsumer`.

**Key Methods:**
- `connect()`: 
  - Extracts `room_name` from the URL.
  - Adds the user's connection to a specific "Group" (e.g., `chat_general`).
  - Accepts the WebSocket connection.
  
- `receive(text_data)`:
  - Triggered when the server receives a message from the client.
  - Parses the JSON data.
  - **Persistence**: Calls `save_message` to save the chat to the SQLite database.
  - **Broadcast**: Sends the message to the Channel Layer group.

- `chat_message(event)`:
  - Triggered when the Channel Layer broadcasts a message to the group.
  - Sends the message payload down to the actual WebSocket client.

- `disconnect()`:
  - Removes the user from the Channel Layer group.

**Database Sync**:
Since Consumers are async, we used `@database_sync_to_async` to safely perform synchronous database operations (saving messages) without blocking the async event loop.

### 4.4. Models (`chat/models.py`)
We created two models to support persistence:
- **`ChatRoom`**: Represents a conversation (Group or Private). Stores participants.
- **`Message`**: Stores the sender, room, content, and timestamp.

### 4.5. Views (`chat/views.py`)
Standard Django views were used for:
- **Login**: A simple session-based login (no password).
- **Lobby**: Listing active public rooms and users.
- **Room View**: Rendering the chat template and fetching historical messages (`Message.objects.filter(...)`) to show upon joining.

### 4.6. Frontend (`chatPage.html`)
- **WebSocket Connection**: 
  `const chatSocket = new WebSocket('ws://' + window.location.host + '/ws/chat/group/' + roomName + '/');`
- **Sending**: Captures input and sends JSON string via `chatSocket.send()`.
- **Receiving**: Listens to `chatSocket.onmessage` and appends new messages to the DOM.

5. Summary of Workflow
----------------------
1. User enters username -> Session created.
2. User joins "general" room -> HTTP Request -> View renders template with old messages.
3. Browser opens WebSocket connection to `/ws/chat/group/general/`.
4. `ChatConsumer` accepts connection and adds user to `chat_general` group.
5. User types "Hello" -> JS sends via WebSocket.
6. `ChatConsumer.receive` gets "Hello" -> Saves to DB -> Sends to `chat_general` group.
7. All users in `chat_general` (including sender) receive event -> `chat_message` sends JSON to browser.
8. Browsers update the chat window.

6. Future Improvements (Production)
-----------------------------------
- Replace `InMemoryChannelLayer` with `RedisChannelLayer` for scalability.
- Add proper user authentication (passwords).

7. Recent Updates (Typing & Read Receipts)
------------------------------------------
We have enhanced the application with the following features:

### 7.1. Redis Channel Layer
- **Why**: `InMemoryChannelLayer` is not suitable for production or multi-worker environments.
- **Change**: Switched to `channels_redis.core.RedisChannelLayer` in `settings.py`.
- **Config**: Connects to Redis on `127.0.0.1:6379`.

### 7.2. Typing Indicators
- **Frontend**: 
  - Listens for `input` events on the chat box.
  - Sends a WebSocket message `{type: "typing", is_typing: true}`.
  - Debounces the event to avoid flooding.
  - Sends `is_typing: false` after 2 seconds of inactivity or upon sending a message.
  - Displays "User is typing..." when receiving the event.
- **Backend**:
  - `ChatConsumer` listens for `typing` message type.
  - Broadcasts `user_typing` event to the group.

### 7.3. Read Receipts
- **Model**: Added `read_by = models.ManyToManyField(User)` to `Message` model.
- **Frontend**:
  - When a message is received (via WebSocket) and the window is focused, sends `{type: "read_receipt", message_id: ...}`.
  - Updates the UI to show "Read" when a receipt is received.
- **Backend**:
  - `ChatConsumer` listens for `read_receipt`.
  - Updates the database (`message.read_by.add(user)`).
  - Broadcasts `message_read` event to the group.

### 7.4. Premium UI Overhaul
- **Theme**: Switched to a "Light" theme inspired by WhatsApp.
  - Background: Subtle pattern on beige.
  - Bubbles: Green for sent, White for received.
- **Message Grouping**: Messages are now grouped by date (Today, Yesterday, etc.) using Django's `regroup` tag.
- **Timestamps**: Each message now displays its timestamp (HH:MM) at the bottom right.
- **Read Receipts**:
  - Single Tick (✓): Sent.
  - Double Tick (✓✓): Read (Blue).
  - **Bulk Read**: When a user joins a room, all unread messages are marked as read, and a `bulk_read` event is broadcast to update the sender's UI instantly.
- **Notifications**:
  - **Unread Counts**: The lobby displays a green badge with the count of unread messages for each private chat.

8. Future Improvements
----------------------
- **Dockerization**: Containerize the application for easy deployment.
- **File Sharing**: Support for images and documents.
- **User Profiles**: Avatars and status messages.
- **Delivery Status**: Implement "Delivered" (Double Grey Tick) by tracking socket acknowledgments.
