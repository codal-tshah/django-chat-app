{% extends 'base.html' %}

{% block title %}
{% if room_type == 'private' %}
Chat with {{ other_user.username }}
{% else %}
#{{ room_name }}
{% endif %}
{% endblock %}

{% block extra_head %}
<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 140px);
        background-color: var(--bg-color);
        background-image: url("https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png");
        /* Subtle pattern */
        background-blend-mode: overlay;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 1rem 2rem;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
    }

    .date-divider {
        align-self: center;
        background-color: #ffffff;
        color: #54656f;
        padding: 5px 12px;
        border-radius: 8px;
        font-size: 0.8rem;
        margin: 1rem 0;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .message {
        max-width: 65%;
        padding: 6px 7px 8px 9px;
        border-radius: 8px;
        position: relative;
        word-wrap: break-word;
        font-size: 0.95rem;
        line-height: 1.3;
        box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.13);
        margin-bottom: 4px;
    }

    .message.sent {
        align-self: flex-end;
        background-color: var(--primary-color);
        color: #111b21;
        border-top-right-radius: 0;
    }

    .message.received {
        align-self: flex-start;
        background-color: #ffffff;
        color: #111b21;
        border-top-left-radius: 0;
    }

    .message .meta {
        display: none;
        /* Hide top meta, we'll put info at bottom */
    }

    .message-content {
        margin-right: 60px;
        /* Space for time */
    }

    .message-info {
        float: right;
        margin-top: -10px;
        margin-left: 8px;
        display: flex;
        align-items: center;
        gap: 3px;
        color: var(--text-secondary);
        font-size: 0.7rem;
    }

    .read-status {
        font-size: 0.9rem;
        font-weight: bold;
        color: var(--text-secondary);
    }

    .read-status.read {
        color: #53bdeb;
        /* Blue ticks */
    }

    .chat-input-area {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        padding: 10px 16px;
        background-color: #f0f2f5;
    }

    #typing-indicator {
        font-size: 0.8rem;
        color: var(--text-secondary);
        height: 1.2rem;
        margin-left: 1rem;
        font-style: italic;
    }
</style>
{% endblock %}

{% block content %}
<div class="card" style="height: 100%; padding: 1rem;">
    <div style="margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center;">
        <h2 style="margin: 0;">
            {% if room_type == 'private' %}
            @{{ other_user.username }}
            {% else %}
            #{{ room_name }}
            {% endif %}
        </h2>
        <div style="display: flex; align-items: center; gap: 1rem;">
            <div style="font-size: 0.85rem; color: var(--text-secondary);">
                <span
                    style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: green; margin-right: 5px;"></span>
                <span id="connection-status" style="color: green;">Connected</span>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="enable-notifications" class="btn btn-secondary"
                    style="display: none; padding: 0.25rem 0.5rem; font-size: 0.8rem; background-color: #53bdeb; border-color: #53bdeb; color: white;">
                    ðŸ”” Enable Notifications
                </button>
                <a href="{% url 'chatPage' %}" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.9rem;">Leave Room</a>
            </div>
        </div>
    </div>

    <div class="chat-container">
        <div class="chat-messages" id="chat-log">
            {% regroup messages by timestamp|date:"Y-m-d" as date_list %}

            {% for date_group in date_list %}
            <div class="date-divider">
                {% if date_group.grouper == now|date:"Y-m-d" %}
                Today
                {% else %}
                {{ date_group.grouper }}
                {% endif %}
            </div>

            {% for message in date_group.list %}
            <div class="message {% if message.sender == current_user %}sent{% else %}received{% endif %}"
                id="msg-{{ message.id }}">

                <div class="message-content">
                    {% if message.sender != current_user and room_type == 'group' %}
                    <div
                        style="font-size: 0.75rem; color: var(--secondary-color); font-weight: bold; margin-bottom: 2px;">
                        {{ message.sender.username }}
                    </div>
                    {% endif %}
                    {{ message.content }}
                </div>

                <div class="message-info">
                    <span class="time">{{ message.timestamp|date:"H:i" }}</span>
                    {% if message.sender == current_user %}
                    {% if message.read_by.count > 1 %}
                    <span class="read-status read">âœ“âœ“</span>
                    {% else %}
                    <span class="read-status">âœ“</span>
                    {% endif %}
                    {% endif %}
                </div>
            </div>
            {% endfor %}
            {% endfor %}
        </div>

        <div id="typing-indicator"></div>

        <div class="chat-input-area">
            <input type="text" id="chat-message-input" placeholder="Type a message..." autocomplete="off">
            <button id="chat-message-submit" class="btn">Send</button>
        </div>
    </div>
</div>

{{ room_name|json_script:"room-name" }}
{{ room_type|json_script:"room-type" }}
{{ current_user.username|json_script:"user-username" }}

<script>
    const roomName = JSON.parse(document.getElementById('room-name').textContent);
    const roomType = JSON.parse(document.getElementById('room-type').textContent);
    const username = JSON.parse(document.getElementById('user-username').textContent);

    // Connection management variables
    let messageQueue = [];
    let isConnected = false;
    let chatSocket = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 3000; // 3 seconds

    // Notification variables
    let originalTitle = document.title;
    let unreadCount = 0;

    const notificationBtn = document.getElementById('enable-notifications');

    function checkNotificationPermission() {
        if ('Notification' in window) {
            if (Notification.permission === 'default') {
                notificationBtn.style.display = 'block';
            } else if (Notification.permission === 'granted') {
                notificationBtn.style.display = 'none';
            } else {
                // Denied
                notificationBtn.textContent = 'ðŸš« Notifications Blocked';
                notificationBtn.style.display = 'block';
                notificationBtn.disabled = true;
            }
        }
    }

    if (notificationBtn) {
        notificationBtn.onclick = function () {
            Notification.requestPermission().then(permission => {
                console.log("Notification permission result:", permission);
                checkNotificationPermission();
                if (permission === 'granted') {
                    new Notification("Notifications Enabled!", {
                        body: "You will now receive alerts for new messages.",
                        icon: 'https://cdn-icons-png.flaticon.com/512/733/733585.png'
                    });
                }
            });
        };
    }

    // Initial check
    checkNotificationPermission();

    // Request notification permission on load (some browsers allow this, some don't)
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(checkNotificationPermission);
    }

    // WebSocket URL
    let wsUrl;
    if (roomType === 'private') {
        wsUrl = 'ws://' + window.location.host + '/ws/chat/private/' + roomName + '/';
    } else {
        wsUrl = 'ws://' + window.location.host + '/ws/chat/group/' + roomName + '/';
    }

    // Initialize WebSocket connection
    function initWebSocket() {
        chatSocket = new WebSocket(wsUrl);

        chatSocket.onopen = function (e) {
            console.log('WebSocket connected');
            isConnected = true;
            reconnectAttempts = 0; // Reset on successful connection

            // Update connection status indicator
            updateConnectionStatus('Connected', 'green');

            // Send any queued messages
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                chatSocket.send(JSON.stringify(msg));
                console.log('Sent queued message:', msg);
            }
        };

        chatSocket.onerror = function (e) {
            console.error('WebSocket error:', e);
            isConnected = false;
            updateConnectionStatus('Error', 'red');
        };

        chatSocket.onclose = function (e) {
            console.log('WebSocket closed:', e.code, e.reason);
            isConnected = false;

            // Attempt to reconnect with exponential backoff
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                const delay = RECONNECT_DELAY * reconnectAttempts; // Exponential backoff

                updateConnectionStatus(`Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'orange');
                console.log(`Reconnecting... Attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);

                setTimeout(() => {
                    initWebSocket();
                }, delay);
            } else {
                console.error('Max reconnection attempts reached');
                updateConnectionStatus('Connection Failed', 'red');

                // Show user a more helpful message
                if (confirm('Connection lost. Click OK to refresh the page and reconnect.')) {
                    location.reload();
                }
            }
        };

        chatSocket.onmessage = function (e) {
            const data = JSON.parse(e.data);

            if (data.type === 'chat_message') {
                handleChatMessage(data);
            } else if (data.type === 'typing') {
                handleTyping(data);
            } else if (data.type === 'read_receipt') {
                handleReadReceipt(data);
            } else if (data.type === 'bulk_read') {
                handleBulkRead(data);
            } else if (data.type === 'unread_count_update') {
                // This would be handled if we were on the lobby page
            } else {
                // Fallback for old message format if any
                if (data.message) handleChatMessage(data);
            }
        };
    }

    // Initialize connection
    initWebSocket();

    // Connection status indicator
    function updateConnectionStatus(status, color) {
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = status;
            statusEl.style.color = color;
        }
    }

    function handleChatMessage(data) {
        const message = data.message;
        const sender = data.username;
        const msgId = data.id;

        const chatLog = document.querySelector('#chat-log');
        const messageElement = document.createElement('div');

        const isMe = sender === username;
        console.log(`Notification Debug: Received message from ${sender}. isMe: ${isMe}`);
        messageElement.classList.add('message', isMe ? 'sent' : 'received');
        if (msgId) messageElement.id = `msg-${msgId}`;

        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });

        messageElement.innerHTML = `
            <div class="message-content">
                ${!isMe && roomType === 'group' ? `<div style="font-size: 0.75rem; color: var(--secondary-color); font-weight: bold; margin-bottom: 2px;">${sender}</div>` : ''}
                ${message}
            </div>
            <div class="message-info">
                <span class="time">${time}</span>
                ${isMe ? '<span class="read-status">âœ“</span>' : ''}
            </div>
        `;

        chatLog.appendChild(messageElement);
        chatLog.scrollTop = chatLog.scrollHeight;

        // If I received a message (not from me), send read receipt
        if (!isMe) {
            sendReadReceipt(msgId);

            // Handle notifications if window is not focused
            if (!document.hasFocus()) {
                console.log("Notification Debug: Window is NOT focused");
                console.log("Notification Debug: Permission is", Notification.permission);

                // 1. Desktop Notification
                if ('Notification' in window) {
                    if (Notification.permission === 'granted') {
                        try {
                            const notification = new Notification(`New message from ${sender}`, {
                                body: message,
                                icon: 'https://cdn-icons-png.flaticon.com/512/733/733585.png', // Reliable public icon
                                tag: 'chat-notification'
                            });
                            console.log("Notification Debug: Notification sent successfully");

                            notification.onclick = function () {
                                window.focus();
                                this.close();
                            };
                        } catch (err) {
                            console.error("Notification Debug: Error creating notification:", err);
                        }
                    } else {
                        console.warn("Notification Debug: Permission not granted. Status:", Notification.permission);
                    }
                } else {
                    console.error("Notification Debug: Browser does not support Desktop Notifications");
                }

                // 2. Tab Title Notification
                unreadCount++;
                document.title = `(${unreadCount}) ${originalTitle}`;
            } else {
                console.log("Notification Debug: Window IS focused, skipping desktop notification");
            }
        }
    }

    function handleTyping(data) {
        const typingIndicator = document.getElementById('typing-indicator');
        if (data.username !== username && data.is_typing) {
            typingIndicator.textContent = `${data.username} is typing...`;
        } else if (data.username !== username && !data.is_typing) {
            typingIndicator.textContent = '';
        }
    }

    function handleReadReceipt(data) {
        // Find the message and mark as read
        const msgEl = document.getElementById(`msg-${data.message_id}`);
        if (msgEl && msgEl.classList.contains('sent')) {
            const statusSpan = msgEl.querySelector('.read-status');
            if (statusSpan) {
                statusSpan.innerHTML = 'âœ“âœ“';
                statusSpan.classList.add('read');
            }
        }
    }

    function handleBulkRead(data) {
        data.message_ids.forEach(msgId => {
            const msgEl = document.getElementById(`msg-${msgId}`);
            if (msgEl && msgEl.classList.contains('sent')) {
                const statusSpan = msgEl.querySelector('.read-status');
                if (statusSpan) {
                    statusSpan.innerHTML = 'âœ“âœ“';
                    statusSpan.classList.add('read');
                }
            }
        });
    }

    function sendReadReceipt(msgId) {
        if (!msgId) return;
        const payload = {
            'type': 'read_receipt',
            'message_id': msgId,
            'username': username
        };

        if (isConnected) {
            chatSocket.send(JSON.stringify(payload));
        } else {
            messageQueue.push(payload);
        }
    }

    const messageInput = document.querySelector('#chat-message-input');

    // Typing indicator logic
    let typingTimeout;
    messageInput.addEventListener('input', () => {
        if (isConnected) {
            chatSocket.send(JSON.stringify({
                'type': 'typing',
                'is_typing': true,
                'username': username
            }));
        }

        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            if (isConnected) {
                chatSocket.send(JSON.stringify({
                    'type': 'typing',
                    'is_typing': false,
                    'username': username
                }));
            }
        }, 2000);
    });

    messageInput.focus();
    messageInput.onkeyup = function (e) {
        if (e.key === 'Enter') {
            document.querySelector('#chat-message-submit').click();
        }
    };

    document.querySelector('#chat-message-submit').onclick = function (e) {
        const message = messageInput.value;
        if (message.trim()) {
            const payload = {
                'type': 'chat_message',
                'message': message,
                'username': username
            };

            if (isConnected) {
                chatSocket.send(JSON.stringify(payload));
                messageInput.value = '';
            } else {
                // Queue message for retry
                messageQueue.push(payload);
                console.log('Message queued for retry');

                // Show user feedback
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = 'Queued (will send when reconnected)';
                    statusEl.style.color = 'orange';
                }

                messageInput.value = '';
            }

            // Clear typing immediately
            clearTimeout(typingTimeout);
            if (isConnected) {
                chatSocket.send(JSON.stringify({
                    'type': 'typing',
                    'is_typing': false,
                    'username': username
                }));
            }
        }
    };

    // Scroll to bottom on load
    const chatLog = document.querySelector('#chat-log');
    chatLog.scrollTop = chatLog.scrollHeight;

    // Send read receipts for existing unread messages on load/focus?
    // For simplicity, we'll just handle new messages or when clicking the window
    // Send read receipts for all messages when window is focused
    // Send read receipts for all messages when window is focused
    window.addEventListener('focus', () => {
        // Reset unread count and title
        unreadCount = 0;
        document.title = originalTitle;

        if (isConnected) {
            chatSocket.send(JSON.stringify({
                'type': 'mark_read',
                'username': username
            }));
        }
    });

    // Also call it once on load
    setTimeout(() => {
        if (isConnected) {
            chatSocket.send(JSON.stringify({
                'type': 'mark_read',
                'username': username
            }));
        }
    }, 1000);
</script>
{% endblock %}